# RAM-DESIGN-USING-VERILOG

COMPANY:CODETECH IT SOLUTIONS

NAME:MUZAMMIL AHMED

INTERN ID:CT06DF2017

DOMAIN:VLSI

DURATION:6 WEEKS

MENTOR:NEELA SANTHOSH

The provided simple_sync_ram Verilog module creates a parameterized, single‑port synchronous RAM that is both conceptually straightforward and effectively mapped to FPGA block RAM primitives. Driven by two parameters—DATA_WIDTH (default 8 bits) and ADDR_WIDTH (default 4 bits)—the design supports ADDR_WIDTHstorage locations, in this case 16 bytes, each capable of storing an 8‑bit word. A single 2‑dimensional reg ar ray named mem encapsulates the storage, with the memory depth inferred from ADDR_WIDTH and word width from DATA_WIDTH. The module exposes synchronous interfaces: a clock (clk), write enable (we), an address bus (addr), data input (din), and data output (dout). Internally, an always @(posedge clk) block governs both read and write actions: if we is asserted, the given din is stored to mem[addr], and in all cases dout is assigned the current content of mem[addr]. By executing both operations on the same clock edge, the module ensures fully synchronous behavior, whereby output data is captured on the clock boundary—an essential feature for timing predictability in FPGA logic. This structure yields a “write‑first” or “new‑data during write” behavior, meaning that when a write and read target the same address in the same clock cycle, the freshly written data is immediately supplied to dout. Such behavior is also known as read‑through in memory synchronization parlance.This write‑first operation is one of three standard BRAM modes—in addition to read‑first and no‑change—supported by FPGA vendor tools like Xilinx Vivado and Intel Quartus, ensuring your RTL will map seamlessly to block RAM resources As a single‑port RAM, it only offers a single address and data port, meaning that read and write operations must be time‑multiplexed; you cannot read and write different addresses in the same cycle—a property described in multiple single‑port RAM references . Since both operations are synchronous, there is no non‑registered, combinational read port, which both simplifies layout and ensures precise timing behavior.A key benefit of this implementation is its high compatibility with FPGA synthesis tools: writing synchronous read and write logic in this style generally guarantees inference of dedicated BRAM blocks rather than distributed LUT‑based RAM, especially true in FPGAs from vendors like Xilinx and Intel.The synchronous read ensures the data output is reliably registered, alleviating potential register‑retiming or glitch issues that can otherwise complicate timing closure—a point emphasized in official vendor documentation . If one instead implements an asynchronous read (combinational assign dout = mem[addr]), tools may infer distributed RAM, consuming LUTs rather than BRAMs, and the timing and functionality will differ.Moreover, this design represents the simplest form of a RAM suitable for many embedded applications: it requires no chip‑select (cs) or output‑enable (oe) signals, uses a single clock domain, and does not rely on a separate read address register. While more elaborate schemes—such as dual‑port RAMs, asynchronous read modes, pipelined outputs, byte‑enable masking, or resettable outputs—exist and are supported in FPGA vendor IP libraries.their complexity only becomes necessary in systems requiring simultaneous read/write access, pipeline buffering, or fine‑grained access control. For smaller memory needs, especially under 1–2 KB, register-based RAM could suffice, but the synthesis tools often prefer BRAM inference for synchronous styles like this .
In summary, this simple_sync_ram module expertly balances simplicity with practical hardware mapping: its clean parameterization promotes reuse with different data and address widths; its fully synchronous, single-edge behavior eliminates timing ambiguity; its write‑first behavior on simultaneous access matches common FPGA BRAM modes; and its adherence to vendor‑recommended styles ensures reliable synthesis into efficient memory blocks. This makes it a robust building block for FIFOs, data buffers, small caches, instruction RAM, or any digital design where moderate memory storage is needed and predictable timing behavior is paramount.



